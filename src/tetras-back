#!/usr/bin/perl

# Copyright (C) 2017  Tetras Libre <admin@tetras-libre.fr>
# Author: Beniamine, David <David@Beniamine.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use threads ('yield',
    'stack_size' => 64*4096,
    'exit' => 'threads_only',
    'stringify');
use POSIX;
use MIME::Lite;
use IO::Handle;
use Data::Dumper;
use Cpanel::JSON::XS qw(encode_json);
use Log::Dispatch;
use Getopt::ArgParse;

my $Logger;
my %running_backups;
my $LOGDIR = "/var/log/tetras-back";
my $CFGFILE = "/etc/tetras-back/configuration.pl";

# Read/SaveCfg snippet from
# http://www.perlmonks.org/?displaytype=print;node_id=464358
# Read a configuration file
#   The arg can be a relative or full path, or
#   it can be a file located somewhere in @INC.
sub ReadCfg{
    my $file =  $_[0];

    our $err;

    {   # Put config data into a separate namespace
        package CFG;

        # Process the contents of the config file
        my $rc = do($file);

        # Check for errors
        if ($@) {
            $::err = "ERROR: Failure compiling '$file' - $@";
        } elsif (! defined($rc)) {
            $::err = "ERROR: Failure reading '$file' - $!";
        } elsif (! $rc) {
            $::err = "ERROR: Failure processing '$file'";
        }
    }
    return ($err);
}

# Save configuration data
#   Use the same arg as used with ReadCfg()
#   so that file can be found in the %INC.
sub SaveCfg
{
    my $file =  $_[0];

    my $CFG;
    if (! open($CFG, "> $file")) {
        return ("ERROR: Failure opening '$file' - $!");
    }

    print $CFG <<_MARKER_;
#####
#
# Tetras-back configuration file
#
#####

use strict;
use warnings;

our (%CFG);

# The configuration data
@{[Data::Dumper->Dump([\%CFG::CFG], ['*CFG'])]}
1;
# EOF
_MARKER_

close($CFG);
return (undef);   # Success
}

sub save_config{
    if (my $err = SaveCfg($CFGFILE)) {
        do_stop("Erreur '$err'", 1);
    }
}

# Stop with message given in argument
sub do_stop($$){
    my $message = shift;
    my $error=shift;
    $Logger->alert("Arret du daemon :'$message'");
    close FIFO;
    unlink $CFG::CFG{'fifo'};
    exit($error);
}

# Notify clients of discs modifications
sub notify(){
    my $json = encode_json($CFG::CFG{DISKS});
    for my $client (keys %{$CFG::CFG{CLIENTS}}){
        open CLI, ">>", $client or die "Can't write to $client";
        print CLI "$json\n";
        close CLI
    }
}

# Log the issue as alert and call end_backup
sub handle_backup_failure($$$$$){
    my ($uuid, $name, $subject, $message, $pid) = @_;
    my $status="Echec de la sauvegarde";
    $Logger->alert("$status: sur le disque '$name': '$subject'");
    if ($pid != 0 ){
        kill("SIGTERM", $pid);
    }
    end_backup($uuid, $status, $subject, $message);
}

# Send the mail and exit thread
sub end_backup($$$$){
    my ($uuid, $status, $subject, $message) = @_;
    delete $running_backups{$uuid};
    $CFG::CFG{DISKS}{KNOWN}{$uuid}{last_backup}="$status ".time();
    do_sendmail("$subject", $message);
    save_config();
    notify();
    threads->exit();
}

# Trigger a backup on device give in argument ex /dev/sdc1
sub do_backup($){
    my $disc = shift;
    my $uuid = get_uuid($disc);
    my $name = $CFG::CFG{DISKS}{KNOWN}{$uuid}{name};
    my $pid=0;
    $SIG{KILL} = sub {
        handle_backup_failure($uuid, $name, "Disque arraché pendant la sauvegarde",
            "La sauvegarde est probablement corrompue, veuillez rebancher le
            disque dès que possible", $pid);
    };
    my $error = 0 ;
    $Logger->info("Demarrage de la sauvegarde sur le disque: $name");
    # Start each script
    for my $scr (keys %{$CFG::CFG{'SCRIPTS'}}){
        my $cmd="$CFG::CFG{'scriptdir'}/$scr $CFG::CFG{'SCRIPTS'}{$scr} $disc";
        $Logger->info("Lancement du script de sauvegarde '$cmd");
        $pid = open SCRLOG, '-|', "$cmd 2>&1";
        # Forward script output
        while (my $line = <SCRLOG>){
            $Logger->info($line);
        }
        if (! close(SCRLOG)){
            $error = 1;
        }
        $Logger->info("Script de sauvegarde $scr terminé");
    }
    my $message = "";
    if( $error == 0 ){
        # prepare message and end backup
        my $status = "Sauvegarde reussie";
        my $subject = "$status sur le disque $name";
        $message = "La sauvegarde c'est termine correctement, vous pouvez maintenant debrancher le disque dur";
        $Logger->info($subject);
        end_backup($uuid, $status, $subject, $message);
    } else{
        # handle error
        handle_backup_failure($uuid, $name, "Erreur durant la sauvegarde",
            "La sauvegarde c'est terminée avec au moins une erreur et est donc probablement incomplète, avez vous arraché le disque pendant la sauvegarde ? Essayez de débrancher et rebrancher le disque, si l'erreur persiste contactez vos administrateur.ice.s système au plus vite", 0);
    }
    # Never reached
}

# Send subject, message by email to root
sub do_sendmail($$){
    my ($subject, $message) = @_;

    my $msg = MIME::Lite->new(
        From     => 'tetras-back',
        To       => 'root',
        Subject  => "[Tetras-back] $subject",
        Type     => 'multipart/mixed'
    );
    $msg->attr("content-type.charset" => "UTF-8");
    $msg->attach(
        Type     => 'TEXT',
        Data     => $message,
    );
    # Add your text message.
    $msg->attach(Type        => 'text',
                 Path        => "$LOGDIR/message.log",
                 Filename    => 'message.log',
                 Disposition => 'inline'
    );
    $msg->send;
    $Logger->info("Etat envoyé par email\n");
}

# Retrieve uuid of given device
sub get_uuid($){
    my $dev = shift;
    $Logger->debug("Recherche de l'uuid pour '$dev'");
    my $ret = `blkid $dev`;
    $ret =~ s/^.* UUID="([^"]*)".*$/$1/s;
    return $ret;
}

# Retrieve the uuid of a connected device
sub get_uuid_connected($){
    my $dev = shift;
    for my $uuid (%{$CFG::CFG{DISKS}{CONNECTED}}){
        if ( $CFG::CFG{DISKS}{CONNECTED}{$uuid} eq $dev){
            return $uuid;
        }
    }
    return ""
}

# Callback for Logger
sub format_log{
    my %args = @_;
    my $date = strftime("%F %X", localtime());
    return "$date\t$args{level}\t$args{message}\n";
}

# Main loop
sub start_daemon(){

    # Create the main fifo
    mkfifo($CFG::CFG{'fifo'},700) or die "Impossible de créer la file $CFG::CFG{'fifo'}, est-ce qu'un daemon tourne déjà ?";
    # Exit properly in case of issue
    $SIG{INT} = sub { do_stop("Signal SIGINT reçu",0)};
    $SIG{USR1} = sub { do_stop("Signal SIGUSR1 reçu",0)};
    $SIG{CHLD} = sub { save_config(); notify(); };
    open FIFO, "+<", $CFG::CFG{'fifo'} or die "Can't read from $CFG::CFG{'fifo'}";
    # prepare logs
    mkdir $LOGDIR;
    $Logger = Log::Dispatch->new(
        outputs => [
            [ 'File',   min_level => 'debug', filename => "$LOGDIR/main.log" ],
            [ 'File',   min_level => 'info',  filename => "$LOGDIR/message.log" ],
            [ 'Screen', min_level => 'debug', stderr => 0, newline =>0 ],
        ],
    );
    $Logger->add_callback(\&format_log);
    # Handle runtime errors
    $SIG{__DIE__}  = sub {do_stop(shift,1)};
    $SIG{__WARN__} = sub {$Logger->warning(shift)};
    $Logger->info("Daemon opérationnel");

    # Read fifo
    while(my $line = <FIFO>){
        if ($line =~ /^PLUG (.*)$/){
            my $dev=$1;
            # Retrieve disk UUID
            my $uuid = get_uuid($dev);
            $Logger->info("Disque connecte '$dev', uuid: '$uuid'");
            # Mark disc as present
            $CFG::CFG{DISKS}{CONNECTED}{$uuid}=$dev;
            # Check if disc known
            if(exists($CFG::CFG{DISKS}{KNOWN}{$uuid})){
                # known disc
                $CFG::CFG{DISKS}{KNOWN}{$uuid}{'last_seen'}=time();
                save_config();
                notify();
                $running_backups{$uuid} = threads->create('do_backup', $dev);
            }else{
                save_config();
                notify();
            }
        }elsif ($line =~ /^UNPLUG (.*)$/){
            $Logger->info("Disque retire $1");
            my $uuid = get_uuid_connected($1);
            # Remove uuid from connected
            delete $CFG::CFG{DISKS}{CONNECTED}{$uuid};
            # update last seen
            if(exists($CFG::CFG{DISKS}{KNOWN}{$uuid})){
                $CFG::CFG{DISKS}{KNOWN}{$uuid}{'last_seen'}=time();
            }
            save_config();
            notify();
            if (exists($running_backups{$uuid})){
                $running_backups{$uuid}->kill('SIGKILL');
            }
        }elsif ($line =~ /^SAVE ([^ ]*) (.*)$/){
            # Add the disc as known
            my $uuid=$1;
            my $name=$2;
            $Logger->info("Enregistrement du disque : '$uuid', nom : '$name'");
            $CFG::CFG{DISKS}{KNOWN}{$uuid}={
                name => $name,
                last_seen => time(),
                last_backup => 'Never'
            };
            # Save our configuration file
            save_config();
            notify();
        }elsif ($line =~/^FORGET (.*)$/){
            # Remove the disk
            my $uuid=$1;
            my $name=$CFG::CFG{DISKS}{KNOWN}{$uuid}{name};
            delete $CFG::CFG{DISKS}{KNOWN}{$uuid};
            $Logger->info("Desenregistrement du disque : '$uuid', nom : '$name'");
            save_config();
            notify();
        }elsif ($line =~ /^STOP$/){
            do_stop("Arret demandé par la ligne de commande", 0);
        }elsif ($line =~ /^REGISTER (.*)$/){
            $CFG::CFG{CLIENTS}{$1} = time();
            save_config();
            notify();
            $Logger->debug("Enregistrement de la FIFO client : '$1'");
        }elsif ($line =~ /^UNREGISTER (.*)$/){
            delete $CFG::CFG{CLIENTS}{$1};
            save_config();
            $Logger->debug("Desenregistrement de la FIFO client : $1");
        }else{
            $Logger->alert("Commande inconnue : '$line'");
            do_sendmail("Erreur: commande inconnue",
                "Je viens de recevoir la commande '$line' que je ne sais pas traiter");
        }
    }
}


# Forward the given command to the daemon
sub send_command($){
    my $cmd=shift;
    open FIFO, ">>", $CFG::CFG{'fifo'} or die "Impossible d'écrire sur $CFG::CFG{'fifo'}";
    print FIFO "$cmd\n";
    close FIFO;
    exit;
}

# Read config
if (my $err = ReadCfg($CFGFILE)) {
    do_stop("Erreur '$err'", 1)
}

# Pase args
my $ap = Getopt::ArgParse->new_parser(
    description => 'Programme modulaire de sauvegarde sur disque externe',
);

$ap->add_args(
    ['--start', '-d', type=>'Bool', help=>'Start the daemon'],
    ['--stop', type=>'Bool', help=>'Stop the daemon'],
    ['--register', '-r', type=>'Scalar', metavar=>"FIFO",
        help=>'register a fifo to notify events'],
    ['--unregister', '-l', type=>'Scalar', metavar=>"FIFO",
        help=>'end notifications to FIFO'],
    ['--forget', '-f', type=>'Scalar', metavar=>"UUID",
        help=>'Forget the given disc'],
    ['--save', '-s', type=>'Pair', split=>' ', metavar=>'UUID=NAME',
        help=>'Mark disc UUID as known under name'],
    ['--plug', '-p', type=>'Scalar', metavar=>"device",
        help=>"Notify $0 that a given device has been pluged, should be called by udev rule"],
    ['--unplug', '-u', type=>'Scalar', metavar=>"device",
        help=>"Notify $0 that a given device has been unpluged, should be called by udev rule"],
);
my  $arguments = $ap->parse_args();

if ($arguments->get_attr('start')){
    start_daemon();
}elsif($arguments->get_attr('stop')){
    if ( -e $CFG::CFG{'fifo'}){
        my $th=threads->create('send_command', "STOP");
        # Timeout
        sleep(5);
        if($th->is_running() or -e $CFG::CFG{'fifo'}){
            print "Le daemon de repond pas, suppression de la file $CFG::CFG{'fifo'}\n";
            unlink $CFG::CFG{'fifo'};
            # Avoid perl to yelling at us because of the unjoined thread
            $th->detach();
        }
    }
}elsif($arguments->get_attr('register')){
    send_command("REGISTER ".$arguments->get_attr('register'));
}elsif($arguments->get_attr('unregister')){
    send_command("UNREGISTER ".$arguments->get_attr('unregister'));
}elsif(scalar(keys(%{$arguments->get_attr('save')})) != 0){
    my ($uuid, $name) = %{$arguments->get_attr('save')};
    send_command("SAVE $uuid $name");
}elsif($arguments->get_attr('forget')){
    send_command("FORGET ".$arguments->get_attr('forget'));
}elsif($arguments->get_attr('plug')){
    send_command("PLUG ".$arguments->get_attr('plug'));
}elsif($arguments->get_attr('unplug')){
    send_command("UNPLUG ".$arguments->get_attr('unplug'));
}else{
    print "Please enter one command\n";
    $ap->print_usage;
    exit(1);
}
